
NHN Academy에서 주관하는 Advanced Java 과정에 대한 학습을 진행합니다.

복습 차원에서 해당하는 내용에 대한 정리를 목표로 합니다.

​



일곱 번째 수업에서는 참조 타입에 대해 학습하였습니다.


참조 타입, enum 타입, 공통 참조 타입, 객체 계층구조, java 패키지, 참조 타입 뱐수를 선언하고 사용 실습, 타입 변환, 타입 변환 실습에 관해 학습하였습니다.


이전에 학습하였던 값 타입과 참조 타입 비교를 다시 되새기며 학습하였습니다.


값 타입은 데이터를 직접 포함하고 복사된, 직접 가지는 데이터를 저장합니다.

참조 타입은 데이터(객체)가 있는 곳의 위치를 저장하고 데이터는 분리된 메모리 영역에 저장됩니다.


두 타입 모두 스택에 선언되지만, 참조 타입은 힙 메모리에 데이터를 저장합니다.


참조 타입 변수의 선언과 해제에 대해 학습하였고, 초기화 되지 않은 참조 타입 변수에 대해 학습하였습니다.


<초기화 되지 않은 참조 타입 변수>

-초기화 되지 않은 참조 타입 변수를 참조

- 멤버나 변수에 엑세스 할 수 없음

- 잘못된 참조 검출

- 컴파일러는 정적으로 초기화되지 않은 참조를 검출

- 런타임에 초기화되지 않은 참조 타입에 엑세스하면 NullReferenceException 예외 발생


선언된 참조 변수가 유효한 참조를 가리키도록 초기화가 된 경우에만 참조 변수를 통해 객체의 멤버에 엑세스 할 수 있습니다. 초기화 되지 않아 참조 타입 변수가 유효하지 않으면 멤버 변수나 메소드에 엑세스 할 수 없습니다.


값 타입과 다르게 참조 타입에서는 생성 시 default 값이 없습니다.

따라서 null로 생성되며, 생성자를 통해서 초기화가 필요합니다.


<값 타입의 비교와 참조 타입의 비교>

- 값 타입의 비교

- == 연산자와 != 연산자를 사용하여 값을 비교

- 참조 타입의 비교

- == 연산자와 != 연산자는 값이 아닌, 참조를 비교


string s = "abc";

이와 같은 경우에는 String Constant Area에 값을 할당하고, 이에 대한 주소값을 넘겨줍니다.

string s2 = "abc";

s1 == s2 비교에 대해서 true를 반환합니다.

이유는 해당 데이터를 SCA에서 검사하여, 해당 위치 주소값을 넘겨주어 비교를 하기 때문입니다.


따라서, String에 대해 리터럴로 선언 시는 equal 연산자로 값을 비교가 가능합니다.


<같은 객체에 대한 여려 변수의 참조>

하나의 객체에 대한 여려 변수의 참조

- 두 참조 변수에서 읽기/쓰기는 같은 객체에 적용됨


<메소드 파라미터에 참조 타입 사용>

참조 타입 역시 메소드 파라미터에 사용됨

- 메소드 내부에서의 변경은 원본 소스에 영향을 미침


<enum 타입 선언>

데이터 중에는 몇 가지 한정된 값을 갖는 경우가 많음

- 요일, 월, 계절 등

- 이런 데이터는 실제로 한 가지 값을 가짐

enum 타입은 몇 개의 열거 상수 중 하나를 저장하는 데이터 타입


<enum 값 비교>

enum 객체는 Heap 영역에 저장됨

enum 객체가 생성되면, 모든 enum 변수는 생성된 enum 객체의 위치를 가리킴

- 동등 값 비교: equals 또는 ==

- 비교 연산자 < >, <=, >=는 값을 비교하지 않음


enum 객체는 참조 타입입니다. enum 객체는 초기화되면 Heap 영역 메모리에 생성됩니다. 한 가지 주의할 점은, enum 객체를 생성할 때 new 연산자를 사용하지 않는다는 것입니다. 이는 enum 객체가 생성될 때 새 메모리 영역을 할당하지 않는다는 것입니다.


enum 역시 내부적으로 생성자가 존재하지만 클래스가 로드되는 시점에서 생성되기 때문에 임의로 생성할 수 없습니다. new로 생성되지 않는 enum은 모든 enum 객체 변수가 같은 곳에 생성되어 있는 객체를 참조하게 됩니다.


== 연산자가 참조 타입간에 사용되면 같은 객체를 참조하고 있는지를 비교합니다. 같은 값을 가지고 있는 enum 변수는 같은 객체를 참조하게 되고, 같은 값을 가진 enum 변수를 == 로 비교하면 true를 return 합니다.


따라서, enum 객체간의 ==은 값을 비교한 것과 같은 효과를 냅니다.


<enum 타입 메소드>

enum 클래스는 java.lang.Enum 클래스에 파생됨

상속한 데이터와 메소드를 사용할 수 있음

- name 메소드

- ordinal 메소드

- compareTo 메소드

- valueOf 메소드

- values 메소드


name 메소드

name() 메소드는 enum 객체가 가지고 있는 문자열을 return 합니다. 문자열은 enum 타입을 정의할 때 사용한 상수 이름과 동일합니다.


ordinal 메소드

ordinal() 메소드는 해당 enum 객체가 전체 enum 중 몇 번째 열거 객체인지 알려줍니다. 객체의 순번은 열거 상수의 정의 순서이며, 0에서 시작합니다.


compareTo 메소드

compareTo() 메소드는 메소드 인자로 전달된 enum 타입을 기준으로 전 후로 몇 번째에 위치하는지 비교합니다.


valueOf 메소드

valueOf() 메소드는 인자로 전달된 문자열과 동일한 문자열을 가지는 enum 객체를 반환합니다.


values 메소드

values() 메소드는 해당 enum에 포함된 모든 열거 객체들을 배열로 만들어 return 합니다.


enum 학습을 위해서 이전의 모듈3에서 실습한 Whatday 소스를 다시 가져왔습니다.

해당 소스 코드에서 월에 대한 문자열 배열을 enum을 통해서 할당할 수 있도록 수정합니다.


내용을 입력하세요.
내용을 입력하세요.

<Exception 클래스>

Exception은 클래스로 구현됨

Exception 객체는 예외를 발생시키는데 사용됨

- new 연산자를 사용해서 Exception 객체 생성

- throw 키워드를 사용해서 객체를 던짐

모든 Exception 타입은 Exception 클래스에서 파생된 서브 클래스


<String 클래스>

여러 개의 유니코드 데이터

읽기만 하고 변경할 수 없는 불변 클래스(Immutable class)

배열 형태로 엑세스 할 수 없음


* StringBuffer 또는 StringBuilder 클래스는 String과 함께 사용됩니다. 이 두 클래스는 문자열을 내부 수정을 가능하게 합니다. 이 클래스들은 수정을 위해 반복적으로 객체를 생성하는 번거로움을 없앱니다.



<String 클래스 메소드, 연산자>


length 메소드

length() 메소드는 String 클래스에 포함된 문자열의 길이를 int 타입으로 return 합니다.


charAt 메소드

charAt() 메소드는 해당 문자열의 특성 인덱스에 해당하는 문자를 return 합니다. 해당 문자열의 길이보다 큰 인덱스나 음수가 전달되면 IndexOutOfBoundsException 예외가 발생합니다.


indexOf 메소드

indexOf() 메소드는 해당 문자열에서 특정 문자나 문자열이 처음으로 등장하는 위치의 정수형 인덱스를 return 합니다. 만약 문자열에 전달된 문자나 문자열이 포함되어 있지 않으면 -1을 return 합니다.


concat 메소드

concat() 메소드는 해당 문자열의 뒤에 파라미터 인자로 전달된 문자열을 추가한 새로운 문자열을 return 합니다. 인자로 전달된 문자열의 길이가 0이면 해당 문자열을 그대로 return 합니다.


trim 메소드

trim() 메소드는 해당 문자열의 앞과 뒤에 포함된 모든 공백 문자를 제거합니다.


toUpperCase와 toLowerCase 메소드

toUpperCase() 메소드와 toLowerCase() 메소드는 해당 문자열의 모든 문자를 대문자로 변환하거나 소문자로 변환합니다.


<String 값 비교>

equals 메소드

- String의 참조 위치가 아닌 값을 비교

compareTo 메소드와 compareToIgnoreCase 메소드

- 대소문자를 구분하여 비교

- 사전순 비교

- int 값 return


equals 메소드

String 클래스는 java.lang.Object 클래스에서 상속한 equals 메소드를 가지고 있습니다. 이 메소드는 오버라이드되어 String 객체끼리의 값을 비교하여 같을 경우 true, 다를 경우 false인 Boolean 값을 return 합니다.


compareTo 메소드

compareTo() 메소드는 두 문자열을 정렬 순서에 따라 비교합니다. return하는 값은 비교 결과에 따라 다릅니다.

숫자를 return하는 경우, 두 String 객체의 값을 사전순으로 비교하다가 다른 문자가 발견될 경우 다른 두 문자의 ASCII 코드 값을 뺀 값을 return 합니다.

0을 return하는 경우, 두 문자열의 값이 대소문자를 구분하여 완전히 동일합니다.


compareToIgnoreCase 메소드

compareTo() 메소드와 동일하게 동작하지만 대소문자를 구분하지 않습니다.



<String 비교 연산자>

==와 != 연산자는 값을 직접 비교하지 않음

String 변수는 리터럴을 이용할 때와 new 연산자를 이용할 때 다른 영역에 할당됨

- 리터럴을 사용하는 경우 string constant pool 영역에 할당

- new 연산자를 사용하는 경우 heap 영역에 할당

리터럴로 문자열을 할당하면 string constant pool 영역을 검색하여 같은 문자열 값이 있는 곳의 위치를 반환


이에 대한 내용은 위에서 값 타입과 참조 타입의 비교를 학습하며 이미 설명하였습니다.


<Object 타입>

java.lang.Object

모든 클래스의 슈퍼 클래스


Object 클래스로 형 변환은 암시적

Object 클래스 밑 하위 서브 클래스로의 형 변환은 암시적


<공통 메소드>

모든 참조 타입의 공통 메소드

- 모든 클래스의 슈퍼 클래스

- toString 메소드

- equals 메소드

- clone 메소드

- finalize 메소드


toString 메소드

toString() 메소드는 해당 인스턴스에 대한 정보를 문자열로 반환합니다. 문자열은 클래스의 이름과 함께 구분자로 '@'가 사용되며, 그 뒤로 16진수 해시코드가 추가됩니다. 16진수 해시코드 값은 인스턴스의 주소를 가리키는 값으로 인스턴스마다 다릅니다.


equals 메소드

equals() 메소드는 해당 인스턴스와 파라미터 인자로 전달받은 두 객체의 값을 비교하여 그 결과를 반환합니다. 참조 타입 변수의 값은 참조하고 있는 객체의 위치(주소 값)입니다.


clone 메소드

clone() 메소드는 해당 인스턴스를 복제하여, 새로운 인스턴스를 생성해 return 합니다. clone 메소드는 필드의 값만 복사하는 shadow copy를 수행해 return 하며, deep copy를 위해서는 clone() 메소드를 오버라이드 해야 합니다. clone 메소드는 데이터의 보호를 이유로 Cloneable 인터페이스를 구현한 클래스의 인스턴스만이 사용할 수 있습니다.


finalize 메소드

해당 객체의 사용이 끝난 경우(아무도 참조하지 않는 경우) Garbage Collector가 객체의 리소르를 정리할 것을 표시합니다.


이어서 Java 패키지를 학습하였습니다.

java.lang 패키지, java.util 패키지, java.io 패키지, 기타 유용한 패키지에 대해 개략적으로 학습하였습니다.


참조 타입 변수를 선언하고 사용하는 예제에 대한 실습을 진행하였습니다.

이전에 학습한 BankAccount 예제에서, 하나의 계좌에서 다른 계좌로 송금할 수 있는 메소드를 추가로 구현하였습니다.


내용을 입력하세요.
내용을 입력하세요.

이어서 간단한 문자열 반전 예제에 대해 실습하였습니다.


내용을 입력하세요.
내용을 입력하세요.

텍스트 파일의 소문자 복사본 생성 예제에 대해 실습하였습니다.


내용을 입력하세요.
내용을 입력하세요.


이어서 타입 변환에 대해 학습하였습니다.


값 타입은 참조 타입으로 형 변환이 사실상 되지 않아야 합니다.

그래서 필요한 것이 Wrapper 클래스입니다.


<Wrapper 클래스>

- 기본 데이터 타입(Primitive Data Type)을 객체로 취급해야 하는 경우에 사용

- 8개의 기본 타입에 해당하는 데이터를 객체로 포장

- 각각의 타입에 해당하는 데이터를 인자로 해당 값을 가지는 객체로 생성

- java.lang 패키지에 포함


<Boxing과 Unboxing>

Wrapper 클래스는 산술 연산을 위해 정의되지 않음

- 값을 변경할 수 없음

기본 데이터 타입을 Wrapper 클래스 인스턴스로 변환: Boxing

Wrapper 클래스 인스턴스를 기본 데이터 타입으로 변환: Unboxing


<슈퍼클래스/서브클래스 변환>

슈퍼 클래스로 변환

- 암시적 / 명시적 모두 가능

- 언제나 변환에 성공함

- Object로 변환 가능

서브 클래스로 변환

- 명시적으로 변환

- 바른 타입으로 변환되는지 점검

- 변환되지 않을 경우 ClassCastException 발생


instanceof 연산자

객체의 타입을 확인하는데 사용

변환 가능하면 true 반환


내용을 입력하세요.
내용을 입력하세요.

<Object 타입 변환>

Object는 모든 클래스의 기본 클래스

모든 참조 타입은 Object로 변환 가능

모든 객체는 Object에 할당될 수 있음


<인터페이스 타입 변환>

인터페이스는 인터페이스에 정의된 멤버에 엑세스 하는 데만 사용됨

인터페이스에서 파생된 클래스에 정의된 메소드 및 변수는 인터페이스를 통해 엑세스 할 수 없음


타입 변환 예제에 대해 실습하였습니다.


내용을 입력하세요.
내용을 입력하세요.

서로 다른 객체들에서 추상화가 높은 단계, 추상화가 낮은 단계를 구분하여 생성할 수 있어야 합니다.


동일한 클래스(틀)에서 생성된 객체여도 서로 다른 초기값(상태)을 가지고 생성될 수 있습니다.

객체가 생성될 때 메소드를 호출하기 위해서 필요한 것이 생성자입니다.

생성자는 이후에 더 자세히 학습합니다.




1. 참조 타입의 메모리 할당 및 할당 해제 방법을 설명하세요.


참조 타입은 데이터가 아닌 데이터가 저장된 곳의 위치 값을 저장합니다. 데이터는 분리된 메모리 공간에 저장됩니다.


참조 타입은 이전에 설명한 것과 같이, 스택에 선언되며 힙 메모리 영역에 데이터를 저장합니다.

새 객체에 참조를 할당한 후, 변수는 다른 객체를 참조하도록 할당할 때까지 할당된 객체를 계속 참조합니다.


참조 타입 변수는 유효한 객체를 참조하지 않는 경우 null 값을 가집니다. 참조를 해제하려면 변수에 null을 명시적으로 할당합니다.




2. 참조 타입 변수가 객체를 가리키고 있지 않은 경우 나타나는 값은 무엇인가요? 이런 변수에 액세스하면 어떻게 되나요?


선언된 참조 변수가 유효한 참조를 가리키도록 초기화가 된 경우에만 참조 변수를 통해 객체의 멤버에 엑세스 할 수 있습니다.


이때 참조 변수의 값은 null이며, 변수를 사용 시 런타임은 NullPointerException을 던집니다.




3. String 클래스의 특징에 대해 설명하세요.


String 클래스의 String 타입은 여러 개의 유니코드 데이터를 처리하는데 사용됩니다.

String 클래스는 읽기만 하고 변경할 수 없는 불변 클래스 입니다. 문자열 값을 변경할 수 있는 몇몇 메소드는 String 객체의 값을 변경하는 것이 아니라 변경된 값을 포함한 새 String 객체를 return 합니다.

배열 형태로 엑세스 할 수 없습니다.




4. 모든 클래스의 기본 클래스는 무엇인가요?


Object 클래스는 모든 클래스의 슈퍼 클래스이며 기본 클래스입니다.




5. Object 객체의 메소드를 설명하세요.


모든 참조 타입의 공통 메소드인 Object 객체 메소드로는

toString 메소드

equals 메소드

clone 메소드

finalize 메소드 가 있습니다.


이에 대한 자세한 내용은 위에서 설명하였습니다.




금일의 "불금" 과제로 해당 문제가 제시되었습니다.

https://bookwithmovie.tistory.com/37


Java 백엔드 개발자 3기 불금 문제이미지 썸네일 삭제
Java 백엔드 개발자 3기 불금 문제
아래는 Rational의 ADT 정의입니다. 아래의 ADT 정의에 맞는 Rational 클래스를 작성하고, Rational 객체끼리 연산을 테스크하는 코드를 작성하세요. Rational ADT Overview The Rational data structure stores amd manulates Rational numbers of the form x/y where x and y are integer numbers. This Rational type supports a multitude of arithmetic operations p...

bookwithmovie.tistory.com



내용을 입력하세요.
내용을 입력하세요.

내용을 입력하세요.
내용을 입력하세요.

﻿